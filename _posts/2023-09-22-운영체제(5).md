---
title: "[운영체제] 프로세스관리"
categories: [OS]
tags:
    [
        운영체제
    ]

date: 2023-09-22
last_modified_at: 2023-09-22
excerpt: 프로세스관리
---

## 프로세스 관리 - 1

### 프로세스 구조

실행 중 프로세스 생성 시스템을 호출, 새로운 프로세스를 생성 가능  
이때 프로세스 생성 순서 저장, 부모/자식 관계를 유지하며 계층적으로 생성됨  

- 부모 프로세스(Parent Process) : 생성하는 프로세스
- 자식 프로세스(Child Process) or 서브 프로세스(Sub Process) : 생성되는 프로세스
- 유닉스 시스템의 일반적인 프로세스 계층 구조
    - 처음 부팅 시 식별자(PID, Process ID)가 0인 첫 번째 프로세스 Swapper 생성
    - 이어서 Init(PID=1), Pagedeamon(PID=2) 생성
    - Swapper(PID=0), Pagedeamon(PID=2)를 운영체제(커널) 프로세스라 하며 운영체제 모드에서만 실행
    - 모든 사용자 프로세스는 fork() 명령을 통해 계층적으로 Init의 자식 프로세스로 생성됨

<br/>

### 프로세스 생성
#### 프로세스는 운영체제 또는 다른 사용자의 응용 프로그램 요청에 의해 생성
- 운영체제가 새로운 프로세스를 생성, 추가하려면 프로세스 관리를 위한 프로세스 제어 블록을 만든 후 프로세스에 주소 공간을 할당해야 함
    - 일괄 처리 환경에서는 실행을 위해 작업이 준비 큐에 도착할 때 생성
    - 대화형 환경에서는 새로운 사용자가 로그온(Log-on)할 때 생성


프로세스 생성을 위해 다음과 같은 작업이 필요함
- 프로세스 식별자 결정
- 시스템에 알려진 프로세스 리스트에 식별자 삽입
- 프로세스에 초기 우선 순위 부여
- 프로세스 제어 블록 생성
- 프로세스에 초기 자원 할당

#### 프로세스 생성과정
- 1단계 : 새로운 프로세스에 프로세스 식별자 할당
- 2단계 : 프로세스의 모든 구성 요소를 포함할 수 있는 주소 공간, 프로세스 제어 블록 공간 할당
- 3단계 : 프로세스 제어 블록 초기화
    - 프로세스의 상태 정보/프로그램 카운터/스택 포인터 등의 초기화, 자원 요청, 프로세스 제어 정보(우선 순위)등
- 4단계 : 링크(해당 큐에 삽입)

#### 프로세스가 작업을 수행하기 위해 자원 필요
- 자식 프로세스 생성 시 필요한 자원을 운영체제로부터 직접 또는 부모 프로세스의 자원 일부 사용 가능
- 부모 프로세스는 자식 프로세스에 자원을 나눠주거나 일부 자원 공유 가능
    - 자원의 일부만 사용하도록 제한하면 시스템에 부담을 주는 것을 방지 가능함
    - 프로세스 생성 시 획득하는 다양한 물리적, 논리적 자원 외에도 약간의 초기화 데이터가 부모 프로세스에서 자식 프로세스로 전달되는 경우도 있음

#### 새로운 프로세스 생성 시 실행과 관련해 다음 두 가지 경우가 가능함
- 부모 프로세스와 자식 프로세스가 동시에 실행됨
- 부모 프로세스는 자식 프로세스들이 모두 종료도리 때까지 기다림

#### 새로운 프로세스의 주소 공간은 다음 두 가지 경우가 가능함
- 자식 프로세스가 부모 프로세스의 주소 공간을 복사
    - 유닉스는 각 프로세스마다 정수로 된 고유한 프로세스 식별자를 가짐
    - 새로운 프로세스는 fork() 명령에 의해 생성, 주소 공간은 부모 프로세스의 주소 공간을 복사함
    - 부모 프로세스와 자식 프로세스의 정보 교환이 쉬움
- 자식 프로세스가 별도의 프로그램을 적재

<br/>

### 프로세스 종료
#### 프로세스가 명령 실행 후 종료되고 운영체제에 프로세스 삭제 요청
- 일괄 처리 환경 : 작업 종료를 의미하는 신호로 인터럽트 발생 또는 시스템 호출로 중지 명령 전달, 프로세스 완료
- 대화형 환경 : 사용자가 로그오프(Log-off)하거나 터미널을 닫을 때 또는 오류에 의해 프로세스 종료
- abort 시스템 호출을 이용한 프로세스 종료
    - 종료되는 프로세스를 생성한 부모 프로세스만 호출 가능
    - 부모 프로세스가 자식 프로세스의 생존권을 가져 다른 프로세스가 임의로 작업을 중단시킬 수 없음
    - 자식 프로세스 종료 시 자식 프로세서의 신원(Identity)이 부모 프로세스로 전달

#### 부모 프로세스는 아래의 이유로 자식 프로세스 종료 가능
- 자식 프로세스가 할당된 자원을 초과하여 자원을 사용할 때
- 자식 프로세스에 할당된 작업(Task)이 더 이상 없을 때

#### 연속 종료
- 시스템이 부모 프로세스 종료 시 자식 프로세스의 존재를 허용하지 않아 종료시키는 현상으로 운영체제가 수행함
    - 유닉스에서 exit 명령으로 프로세스 종료, 부모 프로세스는 wait 명령을 사용하여 자식 프로세스의 종료를 기다림
    - wait 명령 : 종료된 자식의 프로세스 식별자를 부모 프로세스에 전달함

#### 프로세스를 종료하는 경우와 그 예
- 정상 종료 : 프로세스가 운영체제의 서비스를 호출한 경우
- 시간 초과 : 프로세스가 명시된 전체 시간을 초과하여 실행되거나 명시된 시간을 초과하면서 어떤 이벤트 발생을 기다리는 경우
- 실패 : 파일 검색 실패, 명시된 횟수를 초과하여 입출력이 실패한 경우
- 산술 오류, 보호 오류, 데이터 오류 등
- 메모리 부족, 접근 위반 등

#### 프로세스를 파괴하는 것
- 제거 시 프로세스에 속한 자원을 시스템에 돌려주고 해당 프로세스는 시스템 리스트나 테이블에서 사라지며, 프로세스 제어 블록 회수
- 프로그램은 디스크에 저장됨

<br/><br/>

## 프로세스 관리 - 2
### 프로세스 중단과 재시작
#### 프로세스 중단(일시 정지)
- 프로세서의 동작 시간과 입출력 동작 시간의 차이로 시스템의 활동 시간이 유휴 상태로 되는 것을 해결 가능
- 장시간 중단되는 경우 해당 프로세스에 할당된 자원을 다시 풀어주어야 하며, 풀어줄 자원의 결정은 자원의 성질에 따라 결정
- 다중 프로그래밍에서 중단은 자원 부족(대기) 상태를 의미하기도 함
    - 다중 프로그래밍 환경에서는 자원의 이용률과 시스템 효율 향상을 위해 자원을 동적으로 할당
    - 교착상태 발생 시 문제 생김
    - 중단 : 할당된 자원을 기다리는 상태
    - 대기 : 자원을 할당 받기 위해 기다리는 상태

#### 운영체제는 다음 두 가지 방법으로 프로세스를 실행 가능
1. 새로운 프로세스를 생성하여 실행
2. 이미 실행 중인 프로세스를 중단시켰다가 다시 실행
    - 시스템 전체의 부하를 증가시키지 않으면서 프로세스에 서비스 제공 가능
    - 특정 이벤트 발생을 기다리며 대기 상태가 되므로 해당 이벤트 발생 시 즉시 실행 상태로 변화 가능

#### 프로세스 재시작
- 중단 원인이 제거되어 프로세스가 다시 실행되는 것
- 중단되었던 프로세스는 중단되었던 지점부터 다시 시작

<br/>

### 프로세스 제거
#### 프로세스 중단과 재시작은 다음과 같은 경우에 발생함
<!-- 그림 -->
<br/>

### 프로세스 우선 순위 변경
#### 프로세스 제어 블록의 우선 순위 값 변경 가능
- 준비 리스트의 프로세스는 프로세서 중심 프로세스(낮은 우선순위)와 입출력 중심 프로세스(높은 우선순위)로 구분
    - 우선 순위가 낮은 프로세스 : 시간 할당량을 크게 제공
    - 우선 순위가 높은 프로세스 : 시간 할당량을 적게 제공

#### ※ 입출력 중심의 프로세스를 자주 짧게 사용, 프로세서 중심 프로세스는 사용 횟수는 적으나 한번에 오래 사용하게 하여 균형을 유지함

- 입출력 프로세스
    - 높은 우선 순위 : 속도가 느리면서 빠른 응답을 요구하는 단말기 입출력 프로세스
    - 낮은 우선 순위 : 속도가 빠른 디스크 입출력 프로세스

#### 프로세스 스케줄러는 준비 리스트의 우선 순위를 이용해 프로세스를 처리
#### 할당 시간을 초과할 경우 프로세스 실행 상태에서 준비 상태로 변경

<br/>

### 문맥 교환(Context Switching)
#### 프로세스 교환
- 실행 중인 프로세스가 인터럽트되면 운영체제가 다른 프로세스를 실행 상태로 변경, 해당 프로세스에 제어를 넘겨주는 과정에서 실행 중인 프로세스로부터 제어를 인수한 운영체제가 또 다른 프로세스에 제어를 넘겨주기 위해 발생
    - 인터럽트 처리 루틴을 실행한 후 현재 실행 중인 프로세스가 재실행될 수 있으므로 대부분의 운영체제는 프로세스 교환으로 인터럽트가 발생하지 않음
    - 트랩은 시스템이 치명적인 오류인지를 판단, 치명적 오류일 경우 프로세스를 종료하면서 프로세스 교환 발생


#### 문맥 교환
- 프로세스를 다른 프로세스로 교환하기 위해 이전 프로세스의 상태 레지스터 내용을 보관하고 다른 프로세스의 레지스터를 적재하는 일련의 과정
    - 프로세스가 "준비->실행", "실행->준비", "실행->대기" 상태로 변할 때 발생
    - 오버헤드가 발생하며 오버헤드는 메모리 속도, 레지스터 수, 특수 명령어의 존재에 따라 다르므로 시스템마다 다름

<!-- 그림 -->


#### 인터럽트(Interrupt)
- 현재 실행되는 프로세스와 별도로 외부에서 발생되는 여러 종류의 이벤트(입출력 동작의 종료 등)에 의해 발생
- 제어가 인터럽트 처리 루틴으로 넘어간 후에도 기본 시스템 관리 작업을 처리, 인터럽트 형태에 따라 관련된 운영체제 루틴으로 분기
- 대표적인 인터럽트 예
    - 입출력 인터럽트
        - 입출력 동작이 발생한 사실을 확인 후 이벤트를 기다리는 프로세스를 준비 상태로 변경, 실행 할 프로세스를 결정
    - 클록 인터럽트
        - 현재 실행 중인 프로세스의 할당 시간을 조사하여 실행 중인 프로세스를 준비 상태로 변경, 다른 프로세스를 디스패치하여 실행 상태로 변경

#### 트랩(Trap)
- 부적절한 파일 접근 또는 현재 실행 중인 프로세스에 의해 발생되는 오류나 예외 상황으로 인해 발생
